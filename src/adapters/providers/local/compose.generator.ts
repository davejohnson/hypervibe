import { z } from 'zod';
import type { Project } from '../../../domain/entities/project.entity.js';
import type { Component, ComponentType } from '../../../domain/entities/component.entity.js';
import { providerRegistry } from '../../../domain/registry/provider.registry.js';

// Credentials schema for local configuration
export const LocalCredentialsSchema = z.object({
  dockerSocket: z.string().default('/var/run/docker.sock'),
});

export type LocalCredentials = z.infer<typeof LocalCredentialsSchema>;

export interface ComposeService {
  image: string;
  ports?: string[];
  environment?: Record<string, string>;
  volumes?: string[];
  restart?: string;
  healthcheck?: {
    test: string[];
    interval: string;
    timeout: string;
    retries: number;
  };
}

export interface ComposeConfig {
  version: string;
  services: Record<string, ComposeService>;
  volumes?: Record<string, object>;
}

const COMPONENT_CONFIGS: Record<
  ComponentType,
  {
    image: string;
    port: number;
    envPrefix: string;
    defaultEnv: Record<string, string>;
    healthcheck?: ComposeService['healthcheck'];
  }
> = {
  postgres: {
    image: 'postgres:16-alpine',
    port: 5432,
    envPrefix: 'POSTGRES',
    defaultEnv: {
      POSTGRES_USER: 'postgres',
      POSTGRES_PASSWORD: 'postgres',
      POSTGRES_DB: 'app',
    },
    healthcheck: {
      test: ['CMD-SHELL', 'pg_isready -U postgres'],
      interval: '5s',
      timeout: '5s',
      retries: 5,
    },
  },
  redis: {
    image: 'redis:7-alpine',
    port: 6379,
    envPrefix: 'REDIS',
    defaultEnv: {},
    healthcheck: {
      test: ['CMD', 'redis-cli', 'ping'],
      interval: '5s',
      timeout: '5s',
      retries: 5,
    },
  },
  mysql: {
    image: 'mysql:8',
    port: 3306,
    envPrefix: 'MYSQL',
    defaultEnv: {
      MYSQL_ROOT_PASSWORD: 'root',
      MYSQL_DATABASE: 'app',
      MYSQL_USER: 'app',
      MYSQL_PASSWORD: 'app',
    },
    healthcheck: {
      test: ['CMD', 'mysqladmin', 'ping', '-h', 'localhost'],
      interval: '5s',
      timeout: '5s',
      retries: 5,
    },
  },
  mongodb: {
    image: 'mongo:7',
    port: 27017,
    envPrefix: 'MONGO',
    defaultEnv: {
      MONGO_INITDB_ROOT_USERNAME: 'mongo',
      MONGO_INITDB_ROOT_PASSWORD: 'mongo',
    },
    healthcheck: {
      test: ['CMD', 'mongosh', '--eval', "db.adminCommand('ping')"],
      interval: '5s',
      timeout: '5s',
      retries: 5,
    },
  },
};

export class ComposeGenerator {
  generateCompose(project: Project, components: ComponentType[]): string {
    const config: ComposeConfig = {
      version: '3.8',
      services: {},
      volumes: {},
    };

    for (const componentType of components) {
      const componentConfig = COMPONENT_CONFIGS[componentType];
      if (!componentConfig) continue;

      const serviceName = componentType;
      const volumeName = `${project.name.toLowerCase().replace(/\s+/g, '-')}-${componentType}-data`;

      config.services[serviceName] = {
        image: componentConfig.image,
        ports: [`${componentConfig.port}:${componentConfig.port}`],
        environment: componentConfig.defaultEnv,
        volumes: [`${volumeName}:/var/lib/${componentType === 'postgres' ? 'postgresql' : componentType}/data`],
        restart: 'unless-stopped',
        healthcheck: componentConfig.healthcheck,
      };

      config.volumes![volumeName] = {};
    }

    return this.toYaml(config);
  }

  generateEnvLocal(project: Project, components: ComponentType[]): string {
    const lines: string[] = [
      `# Local development environment for ${project.name}`,
      `# Generated by Hypervibe`,
      '',
    ];

    for (const componentType of components) {
      const componentConfig = COMPONENT_CONFIGS[componentType];
      if (!componentConfig) continue;

      lines.push(`# ${componentType.charAt(0).toUpperCase() + componentType.slice(1)}`);

      switch (componentType) {
        case 'postgres':
          lines.push(`DATABASE_URL=postgresql://postgres:postgres@localhost:5432/app`);
          lines.push(`POSTGRES_HOST=localhost`);
          lines.push(`POSTGRES_PORT=5432`);
          lines.push(`POSTGRES_USER=postgres`);
          lines.push(`POSTGRES_PASSWORD=postgres`);
          lines.push(`POSTGRES_DB=app`);
          break;
        case 'redis':
          lines.push(`REDIS_URL=redis://localhost:6379`);
          lines.push(`REDIS_HOST=localhost`);
          lines.push(`REDIS_PORT=6379`);
          break;
        case 'mysql':
          lines.push(`MYSQL_URL=mysql://app:app@localhost:3306/app`);
          lines.push(`MYSQL_HOST=localhost`);
          lines.push(`MYSQL_PORT=3306`);
          lines.push(`MYSQL_USER=app`);
          lines.push(`MYSQL_PASSWORD=app`);
          lines.push(`MYSQL_DATABASE=app`);
          break;
        case 'mongodb':
          lines.push(`MONGODB_URL=mongodb://mongo:mongo@localhost:27017`);
          lines.push(`MONGO_HOST=localhost`);
          lines.push(`MONGO_PORT=27017`);
          lines.push(`MONGO_USER=mongo`);
          lines.push(`MONGO_PASSWORD=mongo`);
          break;
      }

      lines.push('');
    }

    return lines.join('\n');
  }

  getComponentBindings(componentType: ComponentType): Record<string, unknown> {
    const config = COMPONENT_CONFIGS[componentType];
    if (!config) return {};

    switch (componentType) {
      case 'postgres':
        return {
          connectionString: 'postgresql://postgres:postgres@localhost:5432/app',
          host: 'localhost',
          port: 5432,
          username: 'postgres',
          password: 'postgres',
          database: 'app',
        };
      case 'redis':
        return {
          connectionString: 'redis://localhost:6379',
          host: 'localhost',
          port: 6379,
        };
      case 'mysql':
        return {
          connectionString: 'mysql://app:app@localhost:3306/app',
          host: 'localhost',
          port: 3306,
          username: 'app',
          password: 'app',
          database: 'app',
        };
      case 'mongodb':
        return {
          connectionString: 'mongodb://mongo:mongo@localhost:27017',
          host: 'localhost',
          port: 27017,
          username: 'mongo',
          password: 'mongo',
        };
      default:
        return {};
    }
  }

  private toYaml(obj: ComposeConfig): string {
    const lines: string[] = [];

    // Version
    lines.push(`version: '${obj.version}'`);
    lines.push('');

    // Services
    lines.push('services:');
    for (const [name, service] of Object.entries(obj.services)) {
      lines.push(`  ${name}:`);
      lines.push(`    image: ${service.image}`);

      if (service.ports && service.ports.length > 0) {
        lines.push('    ports:');
        for (const port of service.ports) {
          lines.push(`      - "${port}"`);
        }
      }

      if (service.environment && Object.keys(service.environment).length > 0) {
        lines.push('    environment:');
        for (const [key, value] of Object.entries(service.environment)) {
          lines.push(`      ${key}: ${value}`);
        }
      }

      if (service.volumes && service.volumes.length > 0) {
        lines.push('    volumes:');
        for (const volume of service.volumes) {
          lines.push(`      - ${volume}`);
        }
      }

      if (service.restart) {
        lines.push(`    restart: ${service.restart}`);
      }

      if (service.healthcheck) {
        lines.push('    healthcheck:');
        lines.push(`      test: ${JSON.stringify(service.healthcheck.test)}`);
        lines.push(`      interval: ${service.healthcheck.interval}`);
        lines.push(`      timeout: ${service.healthcheck.timeout}`);
        lines.push(`      retries: ${service.healthcheck.retries}`);
      }

      lines.push('');
    }

    // Volumes
    if (obj.volumes && Object.keys(obj.volumes).length > 0) {
      lines.push('volumes:');
      for (const volumeName of Object.keys(obj.volumes)) {
        lines.push(`  ${volumeName}:`);
      }
    }

    return lines.join('\n');
  }
}

// Self-register with provider registry
providerRegistry.register({
  metadata: {
    name: 'local',
    displayName: 'Local Development',
    category: 'local',
    credentialsSchema: LocalCredentialsSchema,
  },
  factory: (credentials) => {
    // Local provider returns the ComposeGenerator for generating Docker Compose configs
    return new ComposeGenerator();
  },
});
